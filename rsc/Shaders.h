#pragma once

const char* VShader =
"#version 430 core\n"
"layout(location = 0) in vec3 pos;\n"
//"layout(location = 1) in vec3 COLOR;\n"
"layout(location = 1) in vec3 Normals;\n"
"layout(location = 2) in vec2 TextCoord;\n"
"out vec3 Nnormals;\n"
"out vec3 FragPos;\n"
"out vec2 Texture;\n"
"out float near;\n"
"out float far;\n"
"flat out int isSelected;\n"
"uniform mat4 Model;\n"
"uniform mat4 View;\n"
"uniform mat4 Projection;\n"
"uniform float nearPPlane;\n"
"uniform float farPPlane;\n"
"uniform int Selected;\n"
"vec3 outline = vec3(0);\n"
"vec3 scale = vec3(1.004);\n"
"void main()\n"
"{\n"
"	 if(Selected == 1) outline = vec3(normalize(Normals) * 0.01);\n"
"	 else outline = vec3(0);\n"
"    gl_Position = Projection * View * Model * vec4(pos + outline , 1.0);\n"
"    FragPos = vec3(Model * vec4(pos, 1.0));\n"
"    Nnormals = mat3(transpose(inverse(Model))) * Normals;\n"
"    Texture = TextCoord;\n"
"    near = nearPPlane;\n"
"    far = farPPlane;\n"
"    isSelected = Selected;\n"
"}\n";
const char* FShader =
"#version 430 core\n"
"struct Material {\n"
"   sampler2D ambient;\n"
"   sampler2D diffuse1;\n"
"   sampler2D diffuse2;\n"
"   sampler2D diffuse3;\n"
"   sampler2D specular1;\n"
"   sampler2D specular2;\n"
"   float shininess;\n"
"};\n"
"uniform Material material;\n"
"struct Light \n"
"{\n"
"   vec3 position;\n"
"   vec3 ambient;\n"
"   vec3 diffuse;\n"
"   vec3 specular;\n"
"};\n"
"struct DirectionalLight\n"
"{\n"
"   vec3 direction;\n"
"   vec3 LightColor;\n"
"   vec3 ambient;\n"
"   vec3 diffuse;\n"
"   vec3 specular;\n"
"};\n"
"struct PointLight\n"
"{\n"
"   vec3 position;\n"
"   vec3 LightColor;\n"
"   vec3 ambient;\n"
"   vec3 diffuse;\n"
"   vec3 specular;\n"
"   float constant;\n"
"   float linear;\n"
"   float quadratic;\n"
"};\n"
"struct SpotLight\n"
"{\n"
"   vec3 position;\n"
"   vec3 LightColor;\n"
"   vec3 direction;\n"
"   float IncutOffangle;\n"
"   float OutcutOffangle;\n"
"   vec3 ambient;\n"
"   vec3 diffuse;\n"
"   vec3 specular;\n"
"   float constant;\n"
"   float linear;\n"
"   float quadratic;\n"
"};\n"
"uniform Light light;\n"
"uniform PointLight Plight;\n"
"uniform SpotLight Slight;\n"
"uniform DirectionalLight Dlight;\n"
"uniform vec3 ViewPos;\n"
"in vec3 Nnormals;\n"
"in vec3 FragPos;\n"
"in vec2 Texture;\n"
"in float near;\n"
"in float far;\n"
"flat in int isSelected;\n"
"out vec4 FragColor;\n"
"vec3 CalcDirectionL(DirectionalLight Dlight)\n"
"{\n"
"    vec3 lightDir = normalize(-Dlight.direction);\n"
"    vec3 norm = normalize(Nnormals);\n"
"\n"
"    vec3 ambient = vec3(texture(material.ambient,Texture)) * Dlight.ambient;\n"
"    float diff = max(dot(norm, lightDir), 0.0);\n"
"    vec3 diffuse = diff * vec3(texture(material.diffuse1, Texture)) * Dlight.diffuse;\n"
"    vec3 viewDir = normalize(ViewPos - FragPos);\n"
"    vec3 reflectDir = reflect(-lightDir, norm);\n"
"    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);\n"
"    vec3 specular = spec * vec3(texture(material.specular1, Texture)) * Dlight.specular;\n"
"    return (ambient + diffuse + specular)*Dlight.LightColor;\n"
"}\n"
"vec3 CalcPointL(PointLight Plight)\n"
"{\n"
"    vec3 lightDir = normalize(Plight.position - FragPos);\n"
"    float Distance = length(Plight.position - FragPos);\n"
"    vec3 norm = normalize(Nnormals);\n"
"\n"
"    vec3 ambient = vec3(texture(material.ambient, Texture)) * Plight.ambient;\n"
"    float intesity = 1 / (Plight.constant + (Plight.linear * Distance) + (Plight.quadratic * Distance * Distance));\n"
"    float diff = max(dot(norm, lightDir), 0.0);\n"
"    vec3 diffuse = intesity * diff * vec3(texture(material.diffuse1, Texture)) * Plight.diffuse;\n"
"    vec3 viewDir = normalize(ViewPos - FragPos);\n"
"    vec3 reflectDir = reflect(-lightDir, norm);\n"
"    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);\n"
"    vec3 specular = intesity * spec * vec3(texture(material.specular1, Texture)) * Plight.specular;\n"
"    return (ambient + diffuse + specular)*Dlight.LightColor;\n"
"}\n"
"vec3 CalcSpotL(SpotLight Slight)\n"
"{\n"
"    vec3 lightDir = normalize(Slight.position - FragPos);\n"
"    float Distance = length(Plight.position - FragPos);\n"
"    vec3 norm = normalize(Nnormals);\n"
"\n"
"    vec3 ambient = vec3(texture(material.ambient, Texture)) * Slight.ambient;\n"
"    float intesity = 1 / (Slight.constant + (Slight.linear * Distance) + (Slight.quadratic * Distance * Distance));\n"
"    float diff = max(dot(norm, lightDir), 0.0);\n"
"    vec3 diffuse = intesity * diff * vec3(texture(material.diffuse1, Texture)) * Slight.diffuse;\n"
"    vec3 viewDir = normalize(ViewPos - FragPos);\n"
"    vec3 reflectDir = reflect(-lightDir, norm);\n"
"    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);\n"
"    vec3 specular = intesity * spec * vec3(texture(material.specular1, Texture)) * Slight.specular;\n"
"\n"
"    float theta = dot(lightDir, normalize(-Slight.direction));\n"
"    float epsilon = Slight.IncutOffangle - Slight.OutcutOffangle;\n"
"    float intensity = clamp((theta - Slight.OutcutOffangle) / epsilon, 0.0, 1.0);\n"
"\n"
"    diffuse *= intensity;\n"
"    specular *= intensity;\n"
"    return (ambient + diffuse + specular)*Dlight.LightColor;\n"
"}\n"
""
"\n"

"float CalcDepth(float zValue)\n"
"{\n"
"	 //Linear Depth Calcutaion\n"
"	 float NDC = zValue * 2 - 1;\n"
"	 return ((2.0 * near * far) / (far + near - NDC * (far - near)))/far;\n"
"}\n"

"float NLCalcDepth(float zValue)\n"
"{\n"
"	 // Non Linear Depth Calcutaion\n"
"	 return zValue;\n"
"}\n"

"vec3 Fog(float zValue, vec3 result)\n"
"{\n"
"	 float Foggydepth = pow(CalcDepth(zValue), 0.5);\n"
"	 return mix(result, vec3(0.902, 0.902, 0.980), Foggydepth);\n"
"}\n"

"void main()\n"
"{\n"
"    vec3 result = CalcDirectionL(Dlight);\n"
"    if(isSelected == 1) FragColor = vec4(1, 1, 0.132,1);\n"
"    else FragColor = vec4(result,1.0);\n"
"}\n";


//________________________________


//-------------------------------

// Vertex Shader
const char* LightVShader =
"#version 430\n"
"layout(location = 0) in vec3 pos;\n"
"layout(location = 1) in vec3 Normals;\n"
"layout(location = 2) in vec2 TextCoord;\n"

"uniform mat4 Model;\n"
"uniform mat4 View;\n"
"uniform mat4 Projection;\n"
"out vec3 Nnormals;\n"
"out vec3 FragPos;\n"
"out vec2 Texture;\n"
"void main()\n"
"{\n"
"   gl_Position = Projection * View * Model * vec4(pos, 1.0);\n"
"    FragPos = vec3(Model * vec4(pos, 1.0));\n"
"    Nnormals = mat3(transpose(inverse(Model))) * Normals;\n"
"    Texture = TextCoord;\n"
"}\n";

// Fragment Shader
const char* LightFShader =
"#version 430 core \n"
"out vec4 Texter;\n"
"in vec3 FragPos;\n"
"in vec3 Texture;\n"
"in vec3 Nnormals;\n"
"void main()\n"
"{\n"
"     Texter = vec4(1,1,1,1);\n"
"}\n";

// ------------------------

//inline const char* GetShaders(const char* Path)
//{
//    std::ifstream shader;
//    shader.open(Path);
//    static std::string file;
//    std::ostringstream shaderstream;
//    shader.close();
//    shaderstream << shader.rdbuf();
//    std::string String = shaderstream.str();
//    return String.c_str();
//}

// Vertex Shader
const char* TransparentVS =
"#version 330 core\n"

"layout(location = 0) in vec3 aPos;       // Vertex position\n"
"layout(location = 1) in vec3 Normals;\n"
"layout(location = 2) in vec2 aTexCoord;  // Texture coordinate\n"
//"layout(location = 1) in vec3 COLOR;\n"

"out vec2 TexCoord; // Pass texture coordinate to the fragment shader\n"

"uniform mat4 Model;\n"
"uniform mat4 View;\n"
"uniform mat4 Projection;\n"

"void main()\n"
"{\n"
"    gl_Position = Projection * View * Model * vec4(aPos, 1.0);\n"
"    TexCoord = aTexCoord;\n"
"}\n";

// Fragment Shader
const char* TransparentFS =
"#version 330 core\n"

"struct Material {\n"
"   sampler2D ambient;\n"
"   sampler2D diffuse1;\n"
"   sampler2D diffuse2;\n"
"   sampler2D diffuse3;\n"
"   sampler2D specular1;\n"
"   sampler2D specular2;\n"
"   float shininess;\n"
"};\n"

"uniform Material material;\n"
"out vec4 FragColor;\n"
"in vec2 TexCoord;\n"

"void main()\n"
"{\n"
"	 vec4 res = texture(material.diffuse1, TexCoord);\n"
"	 if(res.a < 0.1)\n"
"	 {\n"
"	 discard;\n"
"	 }\n"
"    FragColor = res ;\n"
"}\n"
;